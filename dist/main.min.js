(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/entities/player.js":[function(require,module,exports){
var Player = function (game, x, y) {
    Phaser.Sprite.call(this, game, x, y, 'testsprite');
    game.add.existing(this);
}

Player.prototype = Object.create(Phaser.Sprite.prototype);
Player.prototype.constructor = Player;

/**
 * Automatically called by World.update
 */
Player.prototype.update = function() {
};

module.exports = Player;

},{}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/lib/bsp.js":[function(require,module,exports){
var random = require('../util/random');

function bsp(width, height) {

  var Leaf = function(x, y, width, height) {
    this.minLeafSize = 6;
    this.y = y;
    this.x = x;
    this.width = width;
    this.height = height;
    this.leftChild = null;
    this.rightChild = null;
  };

  Leaf.prototype.split = function split() {
    if (this.leftChild != null || this.rightChild != null)
      return false;

    // determine direction of split
    // if the width is >25% larger than height, we split vertically
    // if the height is >25% larger than the width, we split horizontally
    // otherwise we split randomly
    var splitHeight = random.getRandomArbitrary(0,1) > 0.5;
    if (this.width > this.height && this.width / this.height >= 1.25)
      splitHeight = false;
    else if (this.height > this.width && this.height / this.width >= 1.25)
      splitHeight = true;

    var max = (splitHeight ? this.height : this.width) - this.minLeafSize; // determine the maximum height or width
    if (max <= this.minLeafSize)
      return false; // the area is too small to split any more...

    var split = random.getRandomInt(this.minLeafSize, max); // determine where we're going to split

    // create our left and right children based on the direction of the split
    if (splitHeight)
    {
      this.leftChild = new Leaf(this.x, this.y, this.width, split);
      this.rightChild = new Leaf(this.x, this.y + split, this.width, this.height - split);
    }
    else
    {
      this.leftChild = new Leaf(this.x, this.y, split, this.height);
      this.rightChild = new Leaf(this.x + split, this.y, this.width - split, this.height);
    }
    return true; // split successful!
  };


  var maxLeafSize = 20;
  var leafs = [];
  var currentLeaf = null;
  var root = new Leaf(0, 0, width, height);
  var output = [];
  leafs.push(root);

  var didSplit = true;

  // we loop through every Leaf in our Vector over and over again, until no more Leafs can be split.
  while (didSplit) {
    didSplit = false;
    for(var i =0;i<leafs.length;i++)
    {
      currentLeaf = leafs[i];
      if (currentLeaf.leftChild == null && currentLeaf.rightChild == null) // if this Leaf is not already split...
      {
        // if this Leaf is too big, or 75% chance...
        if (currentLeaf.width > maxLeafSize || currentLeaf.height > maxLeafSize || random.getRandomArbitrary(0,1) > 0.25) {
          if (currentLeaf.split()) // split the Leaf!
          {
            // if we did split, push the child leafs to the Vector so we can loop into them next
            leafs.push(currentLeaf.leftChild);
            leafs.push(currentLeaf.rightChild);
            didSplit = true;
          }
          else {
            output.push(currentLeaf);
          }
        }
      }
    }
  }
  return output;
}

module.exports = bsp;
},{"../util/random":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/random.js"}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/main.js":[function(require,module,exports){
'use strict';

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'pixelcrawl-game');

window.Utils = require('./utils');
window.playerState = {
    currentLevel: 'Game'
}

game.state.add('Boot', require('./states/boot'));
game.state.add('Splash', require('./states/splash'));
game.state.add('Preloader', require('./states/preloader'));
game.state.add('Menu', require('./states/menu'));
game.state.add('Game', require('./states/game'));

game.state.start('Boot');


},{"./states/boot":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/boot.js","./states/game":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/game.js","./states/menu":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/menu.js","./states/preloader":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/preloader.js","./states/splash":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/splash.js","./utils":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/utils.js"}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    this.load.image('preloader', 'assets/preloader.gif');
  },

  create: function () {
    this.game.input.maxPointers = 1;

    if (this.game.device.desktop) {
      this.game.stage.scale.pageAlignHorizontally = true;
    } else {
      this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      this.game.scale.minWidth =  800;
      this.game.scale.minHeight = 600;
      this.game.scale.maxWidth =1024;
      this.game.scale.maxHeight = 1024;
      this.game.scale.forceLandscape = true;
      this.game.scale.pageAlignHorizontally = true;
      this.game.scale.setScreenSize(true);
    }

    this.game.state.start('Preloader');
  }
};

},{}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/game.js":[function(require,module,exports){
var Player = require('../entities/player');
var Walk = require('../util/walk');
var bug = require('../util/debugger');

var Game = function () {
  this.testentity = null;
};

module.exports = Game;

Game.prototype = {
  create: function () {
    this.game.stage.backgroundColor = 0x444444;
    this.game.physics.startSystem(Phaser.Physics.arcade);
    var x = (this.game.width / 2) - 100;
    var y = (this.game.height / 2) - 50;
    this.map = this.game.add.tilemap();
    //(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid)
    this.map.addTilesetImage('crawl_tileset');
    this.layer1 = this.map.create('level1', 100, 100, 32, 32);
    this.layer1.resizeWorld();
    this.map.fill(809, 0, 0, 100, 100, this.layer1);
    //this.map.fill(0, 10, 10, 5, 8, this.layer1);
    var leafs = bug();
    for(var j=0;j<leafs.length;j++) {
      var currentRoom = leafs[j];
      this.map.fill(0, currentRoom.x+1, currentRoom.y+1, currentRoom.width-2, currentRoom.height-2, this.layer1);
    }
    this.player = this.game.add.sprite(11*32, 11*32, 'player');

    this.game.physics.arcade.enable(this.layer1);
    this.game.physics.arcade.enable(this.player);

    this.map.setCollision(809);
    //Then the physics engine creates collision bodies from the tiles:

    //the camera will follow the player in the world
    this.game.camera.follow(this.player);
    this.player.body.setSize(32, 32, 0, 0);
    //move player with cursor keys
    this.cursors = this.game.input.keyboard.createCursorKeys();


    //this.testentity = new Player(this.game, x, y);
    this.something = new Walk();
    //this.walkData = this.something.drunkardWalk([0,0],100,true);
    //this.testentity.anchor.setTo(0.5, 0.5);

    //this.outlineRoom(this.map,5,5,5,10);

    this.input.onDown.add(this.onInputDown, this);


  },

  update: function () {
    this.game.physics.arcade.collide(this.player, this.layer1);
    //player movement
    this.player.body.velocity.y = 0;
    this.player.body.velocity.x = 0;

    if(this.cursors.up.isDown) {
      this.player.body.velocity.y -= 320;
    }
    else if(this.cursors.down.isDown) {
      this.player.body.velocity.y += 320;
    }
    if(this.cursors.left.isDown) {
      this.player.body.velocity.x -= 320;
    }
    else if(this.cursors.right.isDown) {
      this.player.body.velocity.x += 320;
    }
  },

  onInputDown: function () {
    this.game.state.start('Menu');
  }
};

},{"../entities/player":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/entities/player.js","../util/debugger":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/debugger.js","../util/walk":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/walk.js"}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/menu.js":[function(require,module,exports){
var Menu = function () {
  this.text = null;
};

module.exports = Menu;

Menu.prototype = {

  create: function () {
    var x = this.game.width / 2;
    var y = this.game.height / 2;

    var style = { font: "65px Arial", fill: "#ffffff", align: "center" };

    this.text = this.add.text(x - 300, y - 200, "Press to Start", style);

    this.input.onDown.add(this.onDown, this);
  },

  update: function () {
  },

  onDown: function () {
    this.game.state.start(playerState.currentLevel);
  }
};

},{}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/preloader.js":[function(require,module,exports){
var Preloader = function (game) {
  this.asset = null;
  this.ready = false;
};

module.exports = Preloader;

Preloader.prototype = {

  preload: function () {
    this.asset = this.add.sprite(320, 240, 'preloader');
    this.asset.anchor.setTo(0.5, 0.5);

    this.load.onLoadComplete.addOnce(this.onLoadComplete, this);
    this.load.setPreloadSprite(this.asset);
    this.load.image('testsprite', 'assets/test.png');
    this.load.image('rougelite','assets/tileset/tile.png');
    this.load.image('crawl_tileset','assets/tileset/crawl_tileset.png');
    this.load.image('player','assets/player.png');
  },

  create: function () {
    this.asset.cropEnabled = false;
  },

  update: function () {
    if (!!this.ready) {
      this.game.state.start('Menu');
    }
  },

  onLoadComplete: function () {
    this.ready = true;
  }
};

},{}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/states/splash.js":[function(require,module,exports){
var Splash = function () {
};

module.exports = Splash;

Splash.prototype = {
  create: function () {
  }
};
},{}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/debugger.js":[function(require,module,exports){
var bsp = require('../lib/bsp');

module.exports = function test() {
  var leafs = bsp(100,100);
  return leafs;
};
},{"../lib/bsp":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/lib/bsp.js"}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/random.js":[function(require,module,exports){
/**
 * Returns a random number between min (inclusive) and max (exclusive)
 */
module.exports.getRandomArbitrary = function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
};

/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 */
module.exports.getRandomInt = function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
/**
 * Shuffle an array randomly
 * @param array
 * @returns {*}
 */
module.exports.shuffleArray = function shuffleArray(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
  return array;
};

},{}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/walk.js":[function(require,module,exports){
var random = require('../util/random');

var Walk = function() {
  var something;
};

Walk.prototype.randomWalk = function randomWalk(steps, cardinal) {
  var path = [];
  for (var i = 0; i < steps; i++) {
    path.push(this.randomDirection(cardinal))
  }
  return path;
};

Walk.prototype.drunkardWalk = function drunkardWalk(start, steps, cardinal) {
  var path = [];
  var currentStep = start;
  var nextStep;
  var possibleSteps = this.possibleSteps(cardinal);

  //Loop for n steps
  while (steps > 0) {
    //Get a random shuffled array of all possible steps
    var nextStepList = random.shuffleArray(possibleSteps).slice();
    //Attempt each step in array
    while (nextStepList.length > 0) {
      nextStep = nextStepList.pop();
      var attemptedStep = [currentStep[0] + nextStep[0], currentStep[1] + nextStep[1]];
      //if step has not been taken then take the step
      if (!this.stepInPath(attemptedStep, path)) {
        break;
      }
    }
    //No more steps possible
    if (nextStepList.length == 0) {
      break;
    }
    else {
      currentStep = [currentStep[0] + nextStep[0], currentStep[1] + nextStep[1]];
      console.log(currentStep);
      path.push(currentStep);
      steps--;
    }
  }
  return path;
};
Walk.prototype.stepInPath = function stepInPath(step, path) {
  for (var i = 0; i < path.length; i++) {
    if (step[0] == path[i][0] && step[1] == path[1]) {
      return true;
    }
  }
  return false;
};
Walk.prototype.possibleSteps = function possibleSteps(cardinal) {
  if (cardinal) {
    return [[0, 1], [1, 0], [0, -1], [-1, 0]];
  }
  else {
    return [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
  }
};
Walk.prototype.randomDirection = function randomDirection(cardinal) {
  var direction = 0;
  if (cardinal) {
    direction = random.getRandomInt(0, 3);
    switch (direction) {
      case 0:
        return [0, 1];
      case 1:
        return [1, 0];
      case 2:
        return [0, -1];
      case 3:
        return [-1, 0];
    }
  }
  else {
    direction = random.getRandomInt(0, 7);
    switch (direction) {
      case 0:
        return [0, 1];
      case 1:
        return [1, 1];
      case 2:
        return [1, 0];
      case 3:
        return [1, -1];
      case 4:
        return [0, -1];
      case 5:
        return [-1, -1];
      case 6:
        return [-1, 0];
      case 7:
        return [-1, 1];
    }
  }
};
module.exports = Walk;
},{"../util/random":"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/util/random.js"}],"/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/utils.js":[function(require,module,exports){
var Utils = {
    containsObject: function(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    }
};

module.exports = Utils;
},{}]},{},["/Users/ianlintner/Documents/Projects/pixelcrawl/src/js/main.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvZW50aXRpZXMvcGxheWVyLmpzIiwic3JjL2pzL2xpYi9ic3AuanMiLCJzcmMvanMvbWFpbi5qcyIsInNyYy9qcy9zdGF0ZXMvYm9vdC5qcyIsInNyYy9qcy9zdGF0ZXMvZ2FtZS5qcyIsInNyYy9qcy9zdGF0ZXMvbWVudS5qcyIsInNyYy9qcy9zdGF0ZXMvcHJlbG9hZGVyLmpzIiwic3JjL2pzL3N0YXRlcy9zcGxhc2guanMiLCJzcmMvanMvdXRpbC9kZWJ1Z2dlci5qcyIsInNyYy9qcy91dGlsL3JhbmRvbS5qcyIsInNyYy9qcy91dGlsL3dhbGsuanMiLCJzcmMvanMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIFBsYXllciA9IGZ1bmN0aW9uIChnYW1lLCB4LCB5KSB7XG4gICAgUGhhc2VyLlNwcml0ZS5jYWxsKHRoaXMsIGdhbWUsIHgsIHksICd0ZXN0c3ByaXRlJyk7XG4gICAgZ2FtZS5hZGQuZXhpc3RpbmcodGhpcyk7XG59XG5cblBsYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5TcHJpdGUucHJvdG90eXBlKTtcblBsYXllci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGF5ZXI7XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBjYWxsZWQgYnkgV29ybGQudXBkYXRlXG4gKi9cblBsYXllci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXllcjtcbiIsInZhciByYW5kb20gPSByZXF1aXJlKCcuLi91dGlsL3JhbmRvbScpO1xuXG5mdW5jdGlvbiBic3Aod2lkdGgsIGhlaWdodCkge1xuXG4gIHZhciBMZWFmID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMubWluTGVhZlNpemUgPSA2O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5sZWZ0Q2hpbGQgPSBudWxsO1xuICAgIHRoaXMucmlnaHRDaGlsZCA9IG51bGw7XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCgpIHtcbiAgICBpZiAodGhpcy5sZWZ0Q2hpbGQgIT0gbnVsbCB8fCB0aGlzLnJpZ2h0Q2hpbGQgIT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGRldGVybWluZSBkaXJlY3Rpb24gb2Ygc3BsaXRcbiAgICAvLyBpZiB0aGUgd2lkdGggaXMgPjI1JSBsYXJnZXIgdGhhbiBoZWlnaHQsIHdlIHNwbGl0IHZlcnRpY2FsbHlcbiAgICAvLyBpZiB0aGUgaGVpZ2h0IGlzID4yNSUgbGFyZ2VyIHRoYW4gdGhlIHdpZHRoLCB3ZSBzcGxpdCBob3Jpem9udGFsbHlcbiAgICAvLyBvdGhlcndpc2Ugd2Ugc3BsaXQgcmFuZG9tbHlcbiAgICB2YXIgc3BsaXRIZWlnaHQgPSByYW5kb20uZ2V0UmFuZG9tQXJiaXRyYXJ5KDAsMSkgPiAwLjU7XG4gICAgaWYgKHRoaXMud2lkdGggPiB0aGlzLmhlaWdodCAmJiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQgPj0gMS4yNSlcbiAgICAgIHNwbGl0SGVpZ2h0ID0gZmFsc2U7XG4gICAgZWxzZSBpZiAodGhpcy5oZWlnaHQgPiB0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0IC8gdGhpcy53aWR0aCA+PSAxLjI1KVxuICAgICAgc3BsaXRIZWlnaHQgPSB0cnVlO1xuXG4gICAgdmFyIG1heCA9IChzcGxpdEhlaWdodCA/IHRoaXMuaGVpZ2h0IDogdGhpcy53aWR0aCkgLSB0aGlzLm1pbkxlYWZTaXplOyAvLyBkZXRlcm1pbmUgdGhlIG1heGltdW0gaGVpZ2h0IG9yIHdpZHRoXG4gICAgaWYgKG1heCA8PSB0aGlzLm1pbkxlYWZTaXplKVxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB0aGUgYXJlYSBpcyB0b28gc21hbGwgdG8gc3BsaXQgYW55IG1vcmUuLi5cblxuICAgIHZhciBzcGxpdCA9IHJhbmRvbS5nZXRSYW5kb21JbnQodGhpcy5taW5MZWFmU2l6ZSwgbWF4KTsgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlJ3JlIGdvaW5nIHRvIHNwbGl0XG5cbiAgICAvLyBjcmVhdGUgb3VyIGxlZnQgYW5kIHJpZ2h0IGNoaWxkcmVuIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNwbGl0XG4gICAgaWYgKHNwbGl0SGVpZ2h0KVxuICAgIHtcbiAgICAgIHRoaXMubGVmdENoaWxkID0gbmV3IExlYWYodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHNwbGl0KTtcbiAgICAgIHRoaXMucmlnaHRDaGlsZCA9IG5ldyBMZWFmKHRoaXMueCwgdGhpcy55ICsgc3BsaXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0IC0gc3BsaXQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgdGhpcy5sZWZ0Q2hpbGQgPSBuZXcgTGVhZih0aGlzLngsIHRoaXMueSwgc3BsaXQsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucmlnaHRDaGlsZCA9IG5ldyBMZWFmKHRoaXMueCArIHNwbGl0LCB0aGlzLnksIHRoaXMud2lkdGggLSBzcGxpdCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTsgLy8gc3BsaXQgc3VjY2Vzc2Z1bCFcbiAgfTtcblxuXG4gIHZhciBtYXhMZWFmU2l6ZSA9IDIwO1xuICB2YXIgbGVhZnMgPSBbXTtcbiAgdmFyIGN1cnJlbnRMZWFmID0gbnVsbDtcbiAgdmFyIHJvb3QgPSBuZXcgTGVhZigwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBsZWFmcy5wdXNoKHJvb3QpO1xuXG4gIHZhciBkaWRTcGxpdCA9IHRydWU7XG5cbiAgLy8gd2UgbG9vcCB0aHJvdWdoIGV2ZXJ5IExlYWYgaW4gb3VyIFZlY3RvciBvdmVyIGFuZCBvdmVyIGFnYWluLCB1bnRpbCBubyBtb3JlIExlYWZzIGNhbiBiZSBzcGxpdC5cbiAgd2hpbGUgKGRpZFNwbGl0KSB7XG4gICAgZGlkU3BsaXQgPSBmYWxzZTtcbiAgICBmb3IodmFyIGkgPTA7aTxsZWFmcy5sZW5ndGg7aSsrKVxuICAgIHtcbiAgICAgIGN1cnJlbnRMZWFmID0gbGVhZnNbaV07XG4gICAgICBpZiAoY3VycmVudExlYWYubGVmdENoaWxkID09IG51bGwgJiYgY3VycmVudExlYWYucmlnaHRDaGlsZCA9PSBudWxsKSAvLyBpZiB0aGlzIExlYWYgaXMgbm90IGFscmVhZHkgc3BsaXQuLi5cbiAgICAgIHtcbiAgICAgICAgLy8gaWYgdGhpcyBMZWFmIGlzIHRvbyBiaWcsIG9yIDc1JSBjaGFuY2UuLi5cbiAgICAgICAgaWYgKGN1cnJlbnRMZWFmLndpZHRoID4gbWF4TGVhZlNpemUgfHwgY3VycmVudExlYWYuaGVpZ2h0ID4gbWF4TGVhZlNpemUgfHwgcmFuZG9tLmdldFJhbmRvbUFyYml0cmFyeSgwLDEpID4gMC4yNSkge1xuICAgICAgICAgIGlmIChjdXJyZW50TGVhZi5zcGxpdCgpKSAvLyBzcGxpdCB0aGUgTGVhZiFcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWQgc3BsaXQsIHB1c2ggdGhlIGNoaWxkIGxlYWZzIHRvIHRoZSBWZWN0b3Igc28gd2UgY2FuIGxvb3AgaW50byB0aGVtIG5leHRcbiAgICAgICAgICAgIGxlYWZzLnB1c2goY3VycmVudExlYWYubGVmdENoaWxkKTtcbiAgICAgICAgICAgIGxlYWZzLnB1c2goY3VycmVudExlYWYucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICBkaWRTcGxpdCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY3VycmVudExlYWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJzcDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnYW1lID0gbmV3IFBoYXNlci5HYW1lKDgwMCwgNjAwLCBQaGFzZXIuQVVUTywgJ3BpeGVsY3Jhd2wtZ2FtZScpO1xuXG53aW5kb3cuVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG53aW5kb3cucGxheWVyU3RhdGUgPSB7XG4gICAgY3VycmVudExldmVsOiAnR2FtZSdcbn1cblxuZ2FtZS5zdGF0ZS5hZGQoJ0Jvb3QnLCByZXF1aXJlKCcuL3N0YXRlcy9ib290JykpO1xuZ2FtZS5zdGF0ZS5hZGQoJ1NwbGFzaCcsIHJlcXVpcmUoJy4vc3RhdGVzL3NwbGFzaCcpKTtcbmdhbWUuc3RhdGUuYWRkKCdQcmVsb2FkZXInLCByZXF1aXJlKCcuL3N0YXRlcy9wcmVsb2FkZXInKSk7XG5nYW1lLnN0YXRlLmFkZCgnTWVudScsIHJlcXVpcmUoJy4vc3RhdGVzL21lbnUnKSk7XG5nYW1lLnN0YXRlLmFkZCgnR2FtZScsIHJlcXVpcmUoJy4vc3RhdGVzL2dhbWUnKSk7XG5cbmdhbWUuc3RhdGUuc3RhcnQoJ0Jvb3QnKTtcblxuIiwidmFyIEJvb3QgPSBmdW5jdGlvbiAoKSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb290O1xuXG5Cb290LnByb3RvdHlwZSA9IHtcblxuICBwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sb2FkLmltYWdlKCdwcmVsb2FkZXInLCAnYXNzZXRzL3ByZWxvYWRlci5naWYnKTtcbiAgfSxcblxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdhbWUuaW5wdXQubWF4UG9pbnRlcnMgPSAxO1xuXG4gICAgaWYgKHRoaXMuZ2FtZS5kZXZpY2UuZGVza3RvcCkge1xuICAgICAgdGhpcy5nYW1lLnN0YWdlLnNjYWxlLnBhZ2VBbGlnbkhvcml6b250YWxseSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2FtZS5zY2FsZS5zY2FsZU1vZGUgPSBQaGFzZXIuU2NhbGVNYW5hZ2VyLlNIT1dfQUxMO1xuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbldpZHRoID0gIDgwMDtcbiAgICAgIHRoaXMuZ2FtZS5zY2FsZS5taW5IZWlnaHQgPSA2MDA7XG4gICAgICB0aGlzLmdhbWUuc2NhbGUubWF4V2lkdGggPTEwMjQ7XG4gICAgICB0aGlzLmdhbWUuc2NhbGUubWF4SGVpZ2h0ID0gMTAyNDtcbiAgICAgIHRoaXMuZ2FtZS5zY2FsZS5mb3JjZUxhbmRzY2FwZSA9IHRydWU7XG4gICAgICB0aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2FtZS5zY2FsZS5zZXRTY3JlZW5TaXplKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydCgnUHJlbG9hZGVyJyk7XG4gIH1cbn07XG4iLCJ2YXIgUGxheWVyID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvcGxheWVyJyk7XG52YXIgV2FsayA9IHJlcXVpcmUoJy4uL3V0aWwvd2FsaycpO1xudmFyIGJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWdnZXInKTtcblxudmFyIEdhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudGVzdGVudGl0eSA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XG5cbkdhbWUucHJvdG90eXBlID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdhbWUuc3RhZ2UuYmFja2dyb3VuZENvbG9yID0gMHg0NDQ0NDQ7XG4gICAgdGhpcy5nYW1lLnBoeXNpY3Muc3RhcnRTeXN0ZW0oUGhhc2VyLlBoeXNpY3MuYXJjYWRlKTtcbiAgICB2YXIgeCA9ICh0aGlzLmdhbWUud2lkdGggLyAyKSAtIDEwMDtcbiAgICB2YXIgeSA9ICh0aGlzLmdhbWUuaGVpZ2h0IC8gMikgLSA1MDtcbiAgICB0aGlzLm1hcCA9IHRoaXMuZ2FtZS5hZGQudGlsZW1hcCgpO1xuICAgIC8vKHRpbGVzZXQsIGtleSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCB0aWxlTWFyZ2luLCB0aWxlU3BhY2luZywgZ2lkKVxuICAgIHRoaXMubWFwLmFkZFRpbGVzZXRJbWFnZSgnY3Jhd2xfdGlsZXNldCcpO1xuICAgIHRoaXMubGF5ZXIxID0gdGhpcy5tYXAuY3JlYXRlKCdsZXZlbDEnLCAxMDAsIDEwMCwgMzIsIDMyKTtcbiAgICB0aGlzLmxheWVyMS5yZXNpemVXb3JsZCgpO1xuICAgIHRoaXMubWFwLmZpbGwoODA5LCAwLCAwLCAxMDAsIDEwMCwgdGhpcy5sYXllcjEpO1xuICAgIC8vdGhpcy5tYXAuZmlsbCgwLCAxMCwgMTAsIDUsIDgsIHRoaXMubGF5ZXIxKTtcbiAgICB2YXIgbGVhZnMgPSBidWcoKTtcbiAgICBmb3IodmFyIGo9MDtqPGxlYWZzLmxlbmd0aDtqKyspIHtcbiAgICAgIHZhciBjdXJyZW50Um9vbSA9IGxlYWZzW2pdO1xuICAgICAgdGhpcy5tYXAuZmlsbCgwLCBjdXJyZW50Um9vbS54KzEsIGN1cnJlbnRSb29tLnkrMSwgY3VycmVudFJvb20ud2lkdGgtMiwgY3VycmVudFJvb20uaGVpZ2h0LTIsIHRoaXMubGF5ZXIxKTtcbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgxMSozMiwgMTEqMzIsICdwbGF5ZXInKTtcblxuICAgIHRoaXMuZ2FtZS5waHlzaWNzLmFyY2FkZS5lbmFibGUodGhpcy5sYXllcjEpO1xuICAgIHRoaXMuZ2FtZS5waHlzaWNzLmFyY2FkZS5lbmFibGUodGhpcy5wbGF5ZXIpO1xuXG4gICAgdGhpcy5tYXAuc2V0Q29sbGlzaW9uKDgwOSk7XG4gICAgLy9UaGVuIHRoZSBwaHlzaWNzIGVuZ2luZSBjcmVhdGVzIGNvbGxpc2lvbiBib2RpZXMgZnJvbSB0aGUgdGlsZXM6XG5cbiAgICAvL3RoZSBjYW1lcmEgd2lsbCBmb2xsb3cgdGhlIHBsYXllciBpbiB0aGUgd29ybGRcbiAgICB0aGlzLmdhbWUuY2FtZXJhLmZvbGxvdyh0aGlzLnBsYXllcik7XG4gICAgdGhpcy5wbGF5ZXIuYm9keS5zZXRTaXplKDMyLCAzMiwgMCwgMCk7XG4gICAgLy9tb3ZlIHBsYXllciB3aXRoIGN1cnNvciBrZXlzXG4gICAgdGhpcy5jdXJzb3JzID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmNyZWF0ZUN1cnNvcktleXMoKTtcblxuXG4gICAgLy90aGlzLnRlc3RlbnRpdHkgPSBuZXcgUGxheWVyKHRoaXMuZ2FtZSwgeCwgeSk7XG4gICAgdGhpcy5zb21ldGhpbmcgPSBuZXcgV2FsaygpO1xuICAgIC8vdGhpcy53YWxrRGF0YSA9IHRoaXMuc29tZXRoaW5nLmRydW5rYXJkV2FsayhbMCwwXSwxMDAsdHJ1ZSk7XG4gICAgLy90aGlzLnRlc3RlbnRpdHkuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcblxuICAgIC8vdGhpcy5vdXRsaW5lUm9vbSh0aGlzLm1hcCw1LDUsNSwxMCk7XG5cbiAgICB0aGlzLmlucHV0Lm9uRG93bi5hZGQodGhpcy5vbklucHV0RG93biwgdGhpcyk7XG5cblxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ2FtZS5waHlzaWNzLmFyY2FkZS5jb2xsaWRlKHRoaXMucGxheWVyLCB0aGlzLmxheWVyMSk7XG4gICAgLy9wbGF5ZXIgbW92ZW1lbnRcbiAgICB0aGlzLnBsYXllci5ib2R5LnZlbG9jaXR5LnkgPSAwO1xuICAgIHRoaXMucGxheWVyLmJvZHkudmVsb2NpdHkueCA9IDA7XG5cbiAgICBpZih0aGlzLmN1cnNvcnMudXAuaXNEb3duKSB7XG4gICAgICB0aGlzLnBsYXllci5ib2R5LnZlbG9jaXR5LnkgLT0gMzIwO1xuICAgIH1cbiAgICBlbHNlIGlmKHRoaXMuY3Vyc29ycy5kb3duLmlzRG93bikge1xuICAgICAgdGhpcy5wbGF5ZXIuYm9keS52ZWxvY2l0eS55ICs9IDMyMDtcbiAgICB9XG4gICAgaWYodGhpcy5jdXJzb3JzLmxlZnQuaXNEb3duKSB7XG4gICAgICB0aGlzLnBsYXllci5ib2R5LnZlbG9jaXR5LnggLT0gMzIwO1xuICAgIH1cbiAgICBlbHNlIGlmKHRoaXMuY3Vyc29ycy5yaWdodC5pc0Rvd24pIHtcbiAgICAgIHRoaXMucGxheWVyLmJvZHkudmVsb2NpdHkueCArPSAzMjA7XG4gICAgfVxuICB9LFxuXG4gIG9uSW5wdXREb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdNZW51Jyk7XG4gIH1cbn07XG4iLCJ2YXIgTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50ZXh0ID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVudTtcblxuTWVudS5wcm90b3R5cGUgPSB7XG5cbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHggPSB0aGlzLmdhbWUud2lkdGggLyAyO1xuICAgIHZhciB5ID0gdGhpcy5nYW1lLmhlaWdodCAvIDI7XG5cbiAgICB2YXIgc3R5bGUgPSB7IGZvbnQ6IFwiNjVweCBBcmlhbFwiLCBmaWxsOiBcIiNmZmZmZmZcIiwgYWxpZ246IFwiY2VudGVyXCIgfTtcblxuICAgIHRoaXMudGV4dCA9IHRoaXMuYWRkLnRleHQoeCAtIDMwMCwgeSAtIDIwMCwgXCJQcmVzcyB0byBTdGFydFwiLCBzdHlsZSk7XG5cbiAgICB0aGlzLmlucHV0Lm9uRG93bi5hZGQodGhpcy5vbkRvd24sIHRoaXMpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICB9LFxuXG4gIG9uRG93bjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydChwbGF5ZXJTdGF0ZS5jdXJyZW50TGV2ZWwpO1xuICB9XG59O1xuIiwidmFyIFByZWxvYWRlciA9IGZ1bmN0aW9uIChnYW1lKSB7XG4gIHRoaXMuYXNzZXQgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByZWxvYWRlcjtcblxuUHJlbG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NldCA9IHRoaXMuYWRkLnNwcml0ZSgzMjAsIDI0MCwgJ3ByZWxvYWRlcicpO1xuICAgIHRoaXMuYXNzZXQuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcblxuICAgIHRoaXMubG9hZC5vbkxvYWRDb21wbGV0ZS5hZGRPbmNlKHRoaXMub25Mb2FkQ29tcGxldGUsIHRoaXMpO1xuICAgIHRoaXMubG9hZC5zZXRQcmVsb2FkU3ByaXRlKHRoaXMuYXNzZXQpO1xuICAgIHRoaXMubG9hZC5pbWFnZSgndGVzdHNwcml0ZScsICdhc3NldHMvdGVzdC5wbmcnKTtcbiAgICB0aGlzLmxvYWQuaW1hZ2UoJ3JvdWdlbGl0ZScsJ2Fzc2V0cy90aWxlc2V0L3RpbGUucG5nJyk7XG4gICAgdGhpcy5sb2FkLmltYWdlKCdjcmF3bF90aWxlc2V0JywnYXNzZXRzL3RpbGVzZXQvY3Jhd2xfdGlsZXNldC5wbmcnKTtcbiAgICB0aGlzLmxvYWQuaW1hZ2UoJ3BsYXllcicsJ2Fzc2V0cy9wbGF5ZXIucG5nJyk7XG4gIH0sXG5cbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NldC5jcm9wRW5hYmxlZCA9IGZhbHNlO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghIXRoaXMucmVhZHkpIHtcbiAgICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydCgnTWVudScpO1xuICAgIH1cbiAgfSxcblxuICBvbkxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICB9XG59O1xuIiwidmFyIFNwbGFzaCA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BsYXNoO1xuXG5TcGxhc2gucHJvdG90eXBlID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgfVxufTsiLCJ2YXIgYnNwID0gcmVxdWlyZSgnLi4vbGliL2JzcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlc3QoKSB7XG4gIHZhciBsZWFmcyA9IGJzcCgxMDAsMTAwKTtcbiAgcmV0dXJuIGxlYWZzO1xufTsiLCIvKipcbiAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSlcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0UmFuZG9tQXJiaXRyYXJ5ID0gZnVuY3Rpb24gZ2V0UmFuZG9tQXJiaXRyYXJ5KG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChpbmNsdXNpdmUpXG4gKiBVc2luZyBNYXRoLnJvdW5kKCkgd2lsbCBnaXZlIHlvdSBhIG5vbi11bmlmb3JtIGRpc3RyaWJ1dGlvbiFcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0UmFuZG9tSW50ID0gZnVuY3Rpb24gZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xufTtcbi8qKlxuICogU2h1ZmZsZSBhbiBhcnJheSByYW5kb21seVxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2h1ZmZsZUFycmF5ID0gZnVuY3Rpb24gc2h1ZmZsZUFycmF5KGFycmF5KSB7XG4gIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICB2YXIgdGVtcCA9IGFycmF5W2ldO1xuICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgYXJyYXlbal0gPSB0ZW1wO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn07XG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbC9yYW5kb20nKTtcblxudmFyIFdhbGsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNvbWV0aGluZztcbn07XG5cbldhbGsucHJvdG90eXBlLnJhbmRvbVdhbGsgPSBmdW5jdGlvbiByYW5kb21XYWxrKHN0ZXBzLCBjYXJkaW5hbCkge1xuICB2YXIgcGF0aCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICBwYXRoLnB1c2godGhpcy5yYW5kb21EaXJlY3Rpb24oY2FyZGluYWwpKVxuICB9XG4gIHJldHVybiBwYXRoO1xufTtcblxuV2Fsay5wcm90b3R5cGUuZHJ1bmthcmRXYWxrID0gZnVuY3Rpb24gZHJ1bmthcmRXYWxrKHN0YXJ0LCBzdGVwcywgY2FyZGluYWwpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIGN1cnJlbnRTdGVwID0gc3RhcnQ7XG4gIHZhciBuZXh0U3RlcDtcbiAgdmFyIHBvc3NpYmxlU3RlcHMgPSB0aGlzLnBvc3NpYmxlU3RlcHMoY2FyZGluYWwpO1xuXG4gIC8vTG9vcCBmb3IgbiBzdGVwc1xuICB3aGlsZSAoc3RlcHMgPiAwKSB7XG4gICAgLy9HZXQgYSByYW5kb20gc2h1ZmZsZWQgYXJyYXkgb2YgYWxsIHBvc3NpYmxlIHN0ZXBzXG4gICAgdmFyIG5leHRTdGVwTGlzdCA9IHJhbmRvbS5zaHVmZmxlQXJyYXkocG9zc2libGVTdGVwcykuc2xpY2UoKTtcbiAgICAvL0F0dGVtcHQgZWFjaCBzdGVwIGluIGFycmF5XG4gICAgd2hpbGUgKG5leHRTdGVwTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICBuZXh0U3RlcCA9IG5leHRTdGVwTGlzdC5wb3AoKTtcbiAgICAgIHZhciBhdHRlbXB0ZWRTdGVwID0gW2N1cnJlbnRTdGVwWzBdICsgbmV4dFN0ZXBbMF0sIGN1cnJlbnRTdGVwWzFdICsgbmV4dFN0ZXBbMV1dO1xuICAgICAgLy9pZiBzdGVwIGhhcyBub3QgYmVlbiB0YWtlbiB0aGVuIHRha2UgdGhlIHN0ZXBcbiAgICAgIGlmICghdGhpcy5zdGVwSW5QYXRoKGF0dGVtcHRlZFN0ZXAsIHBhdGgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvL05vIG1vcmUgc3RlcHMgcG9zc2libGVcbiAgICBpZiAobmV4dFN0ZXBMaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjdXJyZW50U3RlcCA9IFtjdXJyZW50U3RlcFswXSArIG5leHRTdGVwWzBdLCBjdXJyZW50U3RlcFsxXSArIG5leHRTdGVwWzFdXTtcbiAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRTdGVwKTtcbiAgICAgIHBhdGgucHVzaChjdXJyZW50U3RlcCk7XG4gICAgICBzdGVwcy0tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5XYWxrLnByb3RvdHlwZS5zdGVwSW5QYXRoID0gZnVuY3Rpb24gc3RlcEluUGF0aChzdGVwLCBwYXRoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGVwWzBdID09IHBhdGhbaV1bMF0gJiYgc3RlcFsxXSA9PSBwYXRoWzFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbldhbGsucHJvdG90eXBlLnBvc3NpYmxlU3RlcHMgPSBmdW5jdGlvbiBwb3NzaWJsZVN0ZXBzKGNhcmRpbmFsKSB7XG4gIGlmIChjYXJkaW5hbCkge1xuICAgIHJldHVybiBbWzAsIDFdLCBbMSwgMF0sIFswLCAtMV0sIFstMSwgMF1dO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBbWzAsIDFdLCBbMSwgMV0sIFsxLCAwXSwgWzEsIC0xXSwgWzAsIC0xXSwgWy0xLCAtMV0sIFstMSwgMF0sIFstMSwgMV1dO1xuICB9XG59O1xuV2Fsay5wcm90b3R5cGUucmFuZG9tRGlyZWN0aW9uID0gZnVuY3Rpb24gcmFuZG9tRGlyZWN0aW9uKGNhcmRpbmFsKSB7XG4gIHZhciBkaXJlY3Rpb24gPSAwO1xuICBpZiAoY2FyZGluYWwpIHtcbiAgICBkaXJlY3Rpb24gPSByYW5kb20uZ2V0UmFuZG9tSW50KDAsIDMpO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbMSwgMF07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbMCwgLTFdO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gWy0xLCAwXTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlyZWN0aW9uID0gcmFuZG9tLmdldFJhbmRvbUludCgwLCA3KTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gWzEsIDFdO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gWzEsIC0xXTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIFswLCAtMV07XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBbLTEsIC0xXTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIFstMSwgMF07XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBbLTEsIDFdO1xuICAgIH1cbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gV2FsazsiLCJ2YXIgVXRpbHMgPSB7XG4gICAgY29udGFpbnNPYmplY3Q6IGZ1bmN0aW9uKG9iaiwgbGlzdCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzOyJdfQ==
